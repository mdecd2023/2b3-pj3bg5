<h1>Home</h1>
<p><span style="vertical-align: inherit;"><span style="vertical-align: inherit;">組員:</span></span></p>
<p><span style="vertical-align: inherit;"><span style="vertical-align: inherit;">40923115 吳圳吉 帳號:jason60714</span></span></p>
<p><span style="vertical-align: inherit;"><span style="vertical-align: inherit;">40923235 40923235</span></span></p>
<p><span style="vertical-align: inherit;"><span style="vertical-align: inherit;">40923130 Martin3130</span></span></p>
<p></p>
<p><span style="vertical-align: inherit;"><span style="vertical-align: inherit;">倉庫:</span></span></p>
<p>     <span> <a href="https://github.com/mdecd2023/2b2-pj2bg15"><span style="vertical-align: inherit;"><span style="vertical-align: inherit;">https://github.com/mdecd2023/2b2-pj2bg15</span></span></a></span></p>
<p><span style="vertical-align: inherit;"><span style="vertical-align: inherit;">網站：</span></span></p>
<p>     <span> <a href="https://mdecd2023.github.io/2b2-pj2bg15/content/index.html"><span style="vertical-align: inherit;"><span style="vertical-align: inherit;">https://mdecd2023.github.io/2b2-pj2bg15/content/index.html</span></span></a></span></p>
<p></p>
<h1>w9h1</h1>
<h2>40923115</h2>
<p>今天重新分組，然後clone新的作業。</p>
<h2>40923130</h2>
<p><span></span>今天的作業是利用鍵盤來控制，對我來說是個很好的幫助，在tutorial1中，我有試試詢問ChatGPT教我寫鍵盤控制的程式碼，但程式碼有些問題，到目前都還沒有成功，所以這個對我來說非常有幫助。</p>
<h2>40923235</h2>
<p></p>
<p>創建新的靜態，途中遇到<img alt="" height="166" src="/images/沒改中文.jpg" width="523"/></p>
<p>解決方法:資料夾名稱不得為中文。</p>
<p></p>
<h1>W10</h1>
<p><strong>工作分配 </strong></p>
<p>40923130:寫Brython 程式</p>
<p>40923115:尋找與回答Teams問題</p>
<p>40923235:尋找與回答Teams問題</p>
<p></p>
<!-- 導入 brython 程式庫 -->
<script src="/static/brython.js"></script>
<script src="/static/brython_stdlib.js"></script>
<!-- 啟動 Brython -->
<script>
window.onload=function(){
brython({debug:1, pythonpath:['/static/','./../downloads/py/']});
}
</script>
<p><!-- 導入 FileSaver 與 filereader --></p>
<p>
<script src="/static/ace/FileSaver.min.js" type="text/javascript"></script>
<script src="/static/ace/filereader.js" type="text/javascript"></script>
</p>
<p><!-- 導入 ace --></p>
<p>
<script src="/static/ace/ace.js" type="text/javascript"></script>
<script src="/static/ace/ext-language_tools.js" type="text/javascript"></script>
<script src="/static/ace/mode-python3.js" type="text/javascript"></script>
<script src="/static/ace/snippets/python.js" type="text/javascript"></script>
</p>
<p><!-- 請注意, 這裡使用 Javascript 將 localStorage["py_src"] 中存在近端瀏覽器的程式碼, 由使用者決定存檔名稱--></p>
<p>
<script type="text/javascript">
function doSave(storage_id, filename){
    var blob = new Blob([localStorage[storage_id]], {type: "text/plain;charset=utf-8"});
    filename = document.getElementById(filename).value
    saveAs(blob, filename+".py");
}
</script>
</p>
<p><!-- 印出版次與關鍵字程式 --></p>
<p>
<script type="text/python3">
from browser import document as doc
import ace
# 清除畫布
def clear_bd(ev):
    bd = doc["brython_div"]
    bd.clear()
# Brython 3.3.4 內建的 container 名稱為  'container' 且 turtle 輸出為 svg 必須使用 div 訂定 id
Ace = ace.Editor(editor_id="kw_editor", console_id="kw_console", container_id="kw__container", storage_id="kw_py_src" )
# 從 gist 取出程式碼後, 放入 editor 作為 default 程式
def run():
    # 利用 get 取下 src 變數值
    try:
        url = doc.query["src"]
    except:
        url = "https://gist.githubusercontent.com/Martin3130/9992b3450a8b2ef02f3f84ece22239cd/raw/1ea25c151429e47e7b15d9232254110762f593a7/W101.py"
    prog = open(url).read()

    # 將程式載入編輯區
    Ace.editor.setValue(prog)
    Ace.editor.scrollToRow(0)
    Ace.editor.gotoLine(0)
    # 直接執行程式
    #ns = {'name':'main'}
    #exec(prog, ns)
    # 按下 run 按鈕
    Ace.run()

# 執行程式, 顯示輸出結果與清除輸出結果及對應按鈕綁定
doc['kw_run'].bind('click', Ace.run)
doc['kw_show_console'].bind('click', Ace.show_console)
doc['kw_clear_console'].bind('click', Ace.clear_console)
doc['clear_bd'].bind('click', clear_bd)
# 呼叫函式執行
run()
</script>
</p>
<p><!-- 用來顯示程式碼的 editor 區域 --></p>
<div id="kw_editor" style="width: 600px; height: 300px;"></div>
<p><!-- 以下的表單與按鈕與前面的 Javascript doSave 函式以及 FileSaver.min.js 互相配合 --></p>
<!-- 存擋表單開始 --><form><label>Filename: <input id="kw_filename" placeholder="input file name" type="text"/>.py</label> <input onclick="doSave('kw_py_src', 'kw_filename');" type="submit" value="Save"/></form><!-- 存擋表單結束 -->
<p></p>
<!-- 執行與清除按鈕開始 -->
<p><button id="kw_run">Run</button> <button id="kw_show_console">Output</button> <button id="kw_clear_console">清除輸出區</button><button id="clear_bd">清除繪圖區</button><button onclick="window.location.reload()">Reload</button></p>
<!-- 執行與清除按鈕結束 -->
<p></p>
<!-- 程式執行 ouput 區 -->
<div style="width: 100%; height: 100%;"><textarea autocomplete="off" id="kw_console"></textarea></div>
<!-- Brython 程式執行的結果, 都以 brython_div 作為切入位置 -->
<div id="brython_div"></div>
<div></div>
<div></div>
<h2>有關 CoppeliaSim zmqRemoteAPI 問題</h2>
<p>Q1.</p>
<p><span>What is zmqRemoteAPI, and how does it relate to CoppeliaSim?</span></p>
<p>Ans.</p>
<p>zmqRemoteAPI 是一個基於 ZeroMQ 的遠程 API 通訊協議，用於在不同的程序之間進行通訊和數據傳輸。它被廣泛地應用在機器人控制、自動化系統和科學模擬等領域中。</p>
<p>CoppeliaSim 是一個功能強大的機器人仿真軟件，可以模擬各種機器人和自動化系統的行為和控制。它支持多種編程語言和通訊協議，包括 zmqRemoteAPI。</p>
<p>在 CoppeliaSim 中，使用者可以通過遠程 API 與 CoppeliaSim 進行交互，控制機器人或自動化系統的運動、感測器和設備的狀態，並且可以獲取仿真數據和視頻流。而 zmqRemoteAPI 就是其中一種可用的遠程 API 通訊協議，它可以讓使用者通過 ZeroMQ 協議與 CoppeliaSim 進行通訊和數據傳輸，實現對 CoppeliaSim 中機器人和自動化系統的控制和監控。</p>
<p>Q2.</p>
<p><span>How do you establish a connection between a Python script and CoppeliaSim using zmqRemoteAPI?</span></p>
<p><span>Ans.</span></p>
<ol>
<li>
<p>在 CoppeliaSim 中啟用 zmqRemoteAPI。在 CoppeliaSim 中，單擊菜單中的“File”-&gt;“Preferences”-&gt;“Remote API”，勾選“Enable the remote API server”選項，選擇“ZeroMQ”通訊協議，然後保存並關閉偏好設置。</p>
</li>
<li>
<p>在 Python 環境中安裝 pyzmq 模塊。可以使用 pip 安裝 pyzmq 模塊，命令為“pip install pyzmq”。</p>
</li>
<li>
<p>在 Python 腳本中創建 ZeroMQ socket 對象。可以使用 pyzmq 提供的 zmq.Context() 方法創建一個 ZeroMQ 的上下文對象，然後使用該對象的 socket() 方法創建一個 socket 對象。</p>
</li>
<li>
<p>通過 socket 對象向 CoppeliaSim 發送遠程 API 請求。可以使用 socket 對象的 send_string() 方法向 CoppeliaSim 發送包含遠程 API 請求命令的字符串，然後等待 CoppeliaSim 返回結果。</p>
</li>
<li>
<p>解析 CoppeliaSim 返回的結果。可以使用 socket 對象的 recv() 方法接收 CoppeliaSim 返回的數據，然後解析數據以獲取所需的信息。</p>
</li>
</ol>
<p>Q3.</p>
<p><span>What are some common use cases for zmqRemoteAPI in CoppeliaSim?</span></p>
<p><span>Ans.</span></p>
<ol>
<li>
<p>控制機器人或自動化系統的運動：使用者可以通過 zmqRemoteAPI 向 CoppeliaSim 發送控制指令，使得機器人或自動化系統按照所需的運動軌跡進行運動。這個功能在機器人控制、自動化系統測試等方面都有廣泛的應用。</p>
</li>
<li>
<p>監控機器人或自動化系統的狀態：使用者可以通過 zmqRemoteAPI 得到機器人或自動化系統的狀態信息，例如位置、速度、加速度、姿態等，以實現對機器人或自動化系統的監控和調試。</p>
</li>
<li>
<p>模擬感測器和設備的輸出：使用者可以通過 zmqRemoteAPI 模擬感測器和設備的輸出，例如激光測距儀、攝像頭、輸送帶等，以測試和驗證控制算法的有效性和穩定性。</p>
</li>
<li>
<p>執行複雜仿真實驗：使用者可以通過 zmqRemoteAPI 在 CoppeliaSim 中建立複雜的仿真場景和實驗，例如多機器人協作、自主導航、物體檢測和識別等，以驗證和優化自主系統的性能和效果。</p>
</li>
</ol>
<p>Q4.</p>
<p><span>What are the advantages and disadvantages of using zmqRemoteAPI compared to other methods of communication between Python and CoppeliaSim?</span></p>
<p><span>Ans.</span></p>
<p>優點：</p>
<ol>
<li>
<p>簡單易用：zmqRemoteAPI 提供了一個簡單而易用的接口，使得使用者可以輕鬆地在 Python 腳本和 CoppeliaSim 之間進行通訊和控制。</p>
</li>
<li>
<p>快速高效：zmqRemoteAPI 使用 ZeroMQ 通訊協議，可以實現快速高效的數據傳輸，對於需要高頻率、高實時性的控制和監控操作非常適用。</p>
</li>
<li>
<p>靈活可擴展：zmqRemoteAPI 提供了多種不同的遠程 API 接口，可以實現多種不同的功能和應用場景，並且支持 Python 和其他編程語言的集成，具有良好的可擴展性。</p>
</li>
</ol>
<p>缺點：</p>
<ol>
<li>
<p>依賴特定庫：zmqRemoteAPI 使用 pyzmq 库實現 ZeroMQ 通訊協議，需要在 Python 環境中安裝相應的庫和依賴，增加了使用的門檻和複雜度。</p>
</li>
<li>
<p>硬件要求高：由於 zmqRemoteAPI 需要在 CoppeliaSim 中啟用遠程 API 服務器，並且需要在 Python 環境中建立 ZeroMQ socket 對象進行通訊，對硬件要求較高，特別是對於低端的硬件平台可能會造成性能瓶頸。</p>
</li>
</ol>
<!-- 導入 gearUtils-0.9.js Cango 齒輪繪圖程式庫 -->
<script src="https://mde.tw/cp2021/cmsimde/static/Cango-24v03-min.js"></script>
<script src="https://mde.tw/cp2021/cmsimde/static/gearUtils-09.js"></script>
<script src="https://mde.tw/cp2021/cmsimde/static/SVGpathUtils-6v03-min.js"></script>
<script src="https://mde.tw/cp2021/cmsimde/static/sylvester.js"></script>
<script src="https://mde.tw/cp2021/cmsimde/static/PrairieDraw.js"></script>
<h1>W11</h1>
<p><iframe allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen="allowfullscreen" frameborder="0" height="315" src="https://www.youtube.com/embed/hhsPWUsCYxY" title="YouTube video player" width="560"></iframe></p>
<p>我們這組是利用老師之前給的紅綠機器人的檔案來更改，把PJ1的場景加入PJ2中，在兩個球門中加上感測器，並加上記分板程式。</p>
<pre class="brush:lua;auto-links:false;toolbar:false" contenteditable="false">function sysCall_init()
    score1 = 0
    
    sensor = sim.getObject('./sensor')
    xml = [[
        &lt;ui title="Scoreboard" closeable="false" resizable="false" style="plastique"&gt;
        &lt;label text="Score:" style="* {background-color: #808080; color: green; font-size: 40px; font-weight: bold; padding: 5px; border-radius: 5px; }" id="10"/&gt;
        &lt;label text="0" style="* {background-color: #FFF; color: #000000; font-size: 40px; font-weight: bold; padding: 5px; border-radius: 5px;}" id="30"/&gt;
     
        &lt;/ui&gt;
    ]]
    ui = simUI.create(xml)
    simUI.setPosition(ui, 0,0, true)
    bubbleRob1 = sim.getObject('/bubbleRob1')
    ball = sim.getObject('/ball')
    bubbleRob2 = sim.getObject('/bubbleRob2')
    initialPosition1 = sim.getObjectPosition(bubbleRob1, -1)
    initialOrientation1 = sim.getObjectOrientation(bubbleRob1, -1)
    initialPosition2 = sim.getObjectPosition(bubbleRob2, -1)
    initialOrientation2 = sim.getObjectOrientation(bubbleRob2, -1)
    initialballPosition = sim.getObjectPosition(ball, -1)
    initialballOrientation = sim.getObjectOrientation(ball, -1)

end


function sysCall_actuation()
    --simUI.setLabelText(ui, 30, tostring(sim.getFloatSignal("myVariable")))
    result=sim.readProximitySensor(sensor)
    if(score1&lt;99)then
        if(result&gt;0)then
            score2 = score1+1
            simUI.setLabelText(ui, 30, tostring(score2))

            sim.setObjectPosition(bubbleRob1, -1, initialPosition1)
            sim.setObjectOrientation(bubbleRob1, -1, initialOrientation1)
            sim.setObjectPosition(bubbleRob2, -1, initialPosition2)
            sim.setObjectOrientation(bubbleRob2, -1, initialOrientation2)
            sim.setObjectPosition(ball, -1, initialballPosition)
            sim.setObjectOrientation(ball, -1, initialballOrientation)

            score1=score2
        end
    else
        sim.pauseSimulation()
    end
end</pre>
<p><br/><br/></p>
<p></p>
<p><a href="/downloads/pj2.ttt" title="場景">場景</a></p>
<p><a href="/downloads/zmq_bubbleRob_green_arrow_key_movement.py">綠球控制</a></p>
<p><a href="/downloads/zmq_bubbleRob_red_wzas_key_movement.py">紅球控制</a></p><h2>h2</h2>
<p>40923235:回答teams問題，模擬coppeliasim足球機器人，尋找製作記分板方式。自評分數:60</p>
<p>40923130:目前做了Brython亂數，建立場景，用鍵盤控制機器人，加入記分板 自評:60</p><h1>pull request</h1>
<p>先fork再到新建倉儲的http複製後貼到.git/config中，內容轉完靜態後，到倉儲點選contribution後持續點選綠色的按鈕。</p>